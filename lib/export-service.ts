import type { TrackingEvent, PrivacyScore } from './types';
import { calculatePrivacyScore } from './privacy-score';

export type ExportFormat = 'csv' | 'json' | 'pdf';

export interface ExportOptions {
  format: ExportFormat;
  dateRange?: {
    start: Date;
    end: Date;
  };
  includeRecommendations?: boolean;
}

/**
 * Export service for tracking data
 */
export class ExportService {
  /**
   * Sanitize CSV value to prevent injection
   */
  private static sanitizeCSVValue(value: string): string {
    // Prevent CSV injection by prefixing dangerous characters
    const sanitized = value.replace(/^[=+\-@]/, "'$&");
    return `"${sanitized.replace(/"/g, '""')}"`;
  }

  /**
   * Export tracking events as CSV
   */
  static async exportAsCSV(events: TrackingEvent[]): Promise<Blob> {
    const headers = [
      'Timestamp',
      'Domain',
      'Tracker Type',
      'Risk Level',
      'Description',
      'URL',
    ];

    const csvContent = [
      headers.join(','),
      ...events.map(event =>
        [
          new Date(event.timestamp).toISOString(),
          this.sanitizeCSVValue(event.domain),
          this.sanitizeCSVValue(event.trackerType),
          this.sanitizeCSVValue(event.riskLevel),
          this.sanitizeCSVValue(event.description),
          this.sanitizeCSVValue(event.url),
        ].join(',')
      ),
    ].join('\n');

    return new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  }

  /**
   * Export tracking events as JSON
   */
  static async exportAsJSON(events: TrackingEvent[]): Promise<Blob> {
    const exportData = {
      exportDate: new Date().toISOString(),
      totalEvents: events.length,
      events: events.map(event => ({
        ...event,
        timestamp: new Date(event.timestamp).toISOString(),
      })),
    };

    const jsonContent = JSON.stringify(exportData, null, 2);
    return new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
  }

  /**
   * Export tracking summary as PDF (text format)
   */
  static async exportAsPDF(
    events: TrackingEvent[],
    privacyScore: PrivacyScore
  ): Promise<Blob> {
    const reportDate = new Date().toLocaleDateString();

    // Efficient min/max calculation for large arrays
    const timeRange =
      events.length > 0
        ? (() => {
            const { min, max } = events.reduce(
              (acc, e) => ({
                min: Math.min(acc.min, e.timestamp),
                max: Math.max(acc.max, e.timestamp),
              }),
              { min: Infinity, max: -Infinity }
            );
            return `${new Date(min).toLocaleDateString()} - ${new Date(max).toLocaleDateString()}`;
          })()
        : 'No data';

    // Group events by domain
    const domainStats = events.reduce(
      (acc, event) => {
        if (!acc[event.domain]) {
          acc[event.domain] = { count: 0, riskLevels: [] };
        }
        acc[event.domain].count++;
        acc[event.domain].riskLevels.push(event.riskLevel);
        return acc;
      },
      {} as Record<string, { count: number; riskLevels: string[] }>
    );

    const pdfContent = `
PHANTOM TRAIL - PRIVACY REPORT
Generated: ${reportDate}
Time Range: ${timeRange}

PRIVACY SCORE: ${privacyScore.score}/100 (Grade: ${privacyScore.grade})

SUMMARY:
- Total Trackers Detected: ${privacyScore.breakdown.totalTrackers}
- High Risk Trackers: ${privacyScore.breakdown.highRisk}
- Medium Risk Trackers: ${privacyScore.breakdown.mediumRisk}
- Low Risk Trackers: ${privacyScore.breakdown.lowRisk}
- HTTPS Secure: ${privacyScore.breakdown.httpsBonus ? 'Yes' : 'No'}
- Excessive Tracking: ${privacyScore.breakdown.excessiveTrackingPenalty ? 'Yes' : 'No'}

TRACKER BREAKDOWN BY DOMAIN:
${Object.entries(domainStats)
  .sort(([, a], [, b]) => b.count - a.count)
  .map(([domain, stats]) => `- ${domain}: ${stats.count} requests`)
  .join('\n')}

RECOMMENDATIONS:
${privacyScore.recommendations.map(rec => `â€¢ ${rec}`).join('\n')}

DETAILED EVENTS:
${events
  .slice(0, 50)
  .map(
    event =>
      `[${new Date(event.timestamp).toLocaleString()}] ${event.domain} - ${event.description} (${event.riskLevel} risk)`
  )
  .join('\n')}

${events.length > 50 ? `\n... and ${events.length - 50} more events` : ''}

---
Report generated by Phantom Trail Privacy Extension
    `.trim();

    return new Blob([pdfContent], { type: 'text/plain;charset=utf-8;' });
  }

  /**
   * Generate filename for export
   */
  static generateFilename(
    format: ExportFormat,
    dateRange?: { start: Date; end: Date }
  ): string {
    const timestamp = new Date().toISOString().split('T')[0];
    const extension = format === 'pdf' ? 'txt' : format; // PDF is actually text format

    if (dateRange) {
      const startDate = dateRange.start.toISOString().split('T')[0];
      const endDate = dateRange.end.toISOString().split('T')[0];
      return `phantom-trail-${startDate}-to-${endDate}.${extension}`;
    }

    return `phantom-trail-report-${timestamp}.${extension}`;
  }

  /**
   * Download blob as file
   */
  static downloadBlob(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * Prepare export data (separated from download for better separation of concerns)
   */
  static async prepareExport(
    events: TrackingEvent[],
    privacyScore: PrivacyScore,
    options: ExportOptions
  ): Promise<{ blob: Blob; filename: string }> {
    let blob: Blob;

    switch (options.format) {
      case 'csv':
        blob = await this.exportAsCSV(events);
        break;
      case 'json':
        blob = await this.exportAsJSON(events);
        break;
      case 'pdf':
        blob = await this.exportAsPDF(events, privacyScore);
        break;
      default:
        throw new Error(`Unsupported export format: ${options.format}`);
    }

    const filename = this.generateFilename(options.format, options.dateRange);
    return { blob, filename };
  }

  /**
   * Generate export for scheduled exports
   */
  static async generateExport(
    events: TrackingEvent[],
    format: ExportFormat
  ): Promise<Blob> {
    switch (format) {
      case 'csv':
        return await this.exportAsCSV(events);
      case 'json':
        return await this.exportAsJSON(events);
      case 'pdf': {
        // For PDF, we need a privacy score for analysis
        const privacyScore = calculatePrivacyScore(events, true);
        return await this.exportAsPDF(events, privacyScore);
      }
      default:
        throw new Error(`Unsupported export format: ${format}`);
    }
  }

  /**
   * Export and download tracking data
   * @deprecated Use prepareExport + downloadBlob for better separation of concerns
   */
  static async exportAndDownload(
    events: TrackingEvent[],
    privacyScore: PrivacyScore,
    options: ExportOptions
  ): Promise<void> {
    const { blob, filename } = await this.prepareExport(
      events,
      privacyScore,
      options
    );
    this.downloadBlob(blob, filename);
  }
}
