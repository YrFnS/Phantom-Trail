/* global Blob */
import type { TrackingEvent, PrivacyScore } from './types';

export type ExportFormat = 'csv' | 'json' | 'pdf';

export interface ExportOptions {
  format: ExportFormat;
  dateRange?: {
    start: Date;
    end: Date;
  };
  includeRecommendations?: boolean;
}

/**
 * Export service for tracking data
 */
export class ExportService {
  /**
   * Export tracking events as CSV
   */
  static async exportAsCSV(events: TrackingEvent[]): Promise<Blob> {
    const headers = [
      'Timestamp',
      'Domain',
      'Tracker Type',
      'Risk Level',
      'Description',
      'URL'
    ];

    const csvContent = [
      headers.join(','),
      ...events.map(event => [
        new Date(event.timestamp).toISOString(),
        `"${event.domain}"`,
        `"${event.trackerType}"`,
        `"${event.riskLevel}"`,
        `"${event.description.replace(/"/g, '""')}"`,
        `"${event.url}"`
      ].join(','))
    ].join('\n');

    return new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  }

  /**
   * Export tracking events as JSON
   */
  static async exportAsJSON(events: TrackingEvent[]): Promise<Blob> {
    const exportData = {
      exportDate: new Date().toISOString(),
      totalEvents: events.length,
      events: events.map(event => ({
        ...event,
        timestamp: new Date(event.timestamp).toISOString(),
      }))
    };

    const jsonContent = JSON.stringify(exportData, null, 2);
    return new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
  }

  /**
   * Export tracking summary as PDF (text format)
   */
  static async exportAsPDF(
    events: TrackingEvent[], 
    privacyScore: PrivacyScore
  ): Promise<Blob> {
    const reportDate = new Date().toLocaleDateString();
    const timeRange = events.length > 0 
      ? `${new Date(Math.min(...events.map(e => e.timestamp))).toLocaleDateString()} - ${new Date(Math.max(...events.map(e => e.timestamp))).toLocaleDateString()}`
      : 'No data';

    // Group events by domain
    const domainStats = events.reduce((acc, event) => {
      if (!acc[event.domain]) {
        acc[event.domain] = { count: 0, riskLevels: [] };
      }
      acc[event.domain].count++;
      acc[event.domain].riskLevels.push(event.riskLevel);
      return acc;
    }, {} as Record<string, { count: number; riskLevels: string[] }>);

    const pdfContent = `
PHANTOM TRAIL - PRIVACY REPORT
Generated: ${reportDate}
Time Range: ${timeRange}

PRIVACY SCORE: ${privacyScore.score}/100 (Grade: ${privacyScore.grade})

SUMMARY:
- Total Trackers Detected: ${privacyScore.breakdown.totalTrackers}
- High Risk Trackers: ${privacyScore.breakdown.highRisk}
- Medium Risk Trackers: ${privacyScore.breakdown.mediumRisk}
- Low Risk Trackers: ${privacyScore.breakdown.lowRisk}
- HTTPS Secure: ${privacyScore.breakdown.httpsBonus ? 'Yes' : 'No'}
- Excessive Tracking: ${privacyScore.breakdown.excessiveTrackingPenalty ? 'Yes' : 'No'}

TRACKER BREAKDOWN BY DOMAIN:
${Object.entries(domainStats)
  .sort(([,a], [,b]) => b.count - a.count)
  .map(([domain, stats]) => `- ${domain}: ${stats.count} requests`)
  .join('\n')}

RECOMMENDATIONS:
${privacyScore.recommendations.map(rec => `â€¢ ${rec}`).join('\n')}

DETAILED EVENTS:
${events.slice(0, 50).map(event => 
  `[${new Date(event.timestamp).toLocaleString()}] ${event.domain} - ${event.description} (${event.riskLevel} risk)`
).join('\n')}

${events.length > 50 ? `\n... and ${events.length - 50} more events` : ''}

---
Report generated by Phantom Trail Privacy Extension
    `.trim();

    return new Blob([pdfContent], { type: 'text/plain;charset=utf-8;' });
  }

  /**
   * Generate filename for export
   */
  static generateFilename(format: ExportFormat, dateRange?: { start: Date; end: Date }): string {
    const timestamp = new Date().toISOString().split('T')[0];
    const extension = format === 'pdf' ? 'txt' : format; // PDF is actually text format
    
    if (dateRange) {
      const startDate = dateRange.start.toISOString().split('T')[0];
      const endDate = dateRange.end.toISOString().split('T')[0];
      return `phantom-trail-${startDate}-to-${endDate}.${extension}`;
    }
    
    return `phantom-trail-report-${timestamp}.${extension}`;
  }

  /**
   * Download blob as file
   */
  static downloadBlob(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * Export and download tracking data
   */
  static async exportAndDownload(
    events: TrackingEvent[],
    privacyScore: PrivacyScore,
    options: ExportOptions
  ): Promise<void> {
    let blob: Blob;
    
    switch (options.format) {
      case 'csv':
        blob = await this.exportAsCSV(events);
        break;
      case 'json':
        blob = await this.exportAsJSON(events);
        break;
      case 'pdf':
        blob = await this.exportAsPDF(events, privacyScore);
        break;
      default:
        throw new Error(`Unsupported export format: ${options.format}`);
    }

    const filename = this.generateFilename(options.format, options.dateRange);
    this.downloadBlob(blob, filename);
  }
}
